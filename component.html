<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Computer Organization Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a2e; color: white; }
        
        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            pointer-events: none; /* Let clicks pass through to 3D scene */
        }
        
        .card {
            background: rgba(22, 33, 62, 0.9);
            border: 1px solid #0f3460;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            pointer-events: auto; /* Re-enable clicks for UI elements */
            transition: transform 0.2s;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.5rem; color: #e94560; }
        h2 { margin: 0 0 5px 0; color: #4db5ff; }
        p { line-height: 1.5; font-size: 0.95rem; color: #ccc; }
        
        .instruction { font-size: 0.8rem; color: #aaa; font-style: italic; }

        /* Buttons */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(233, 69, 96, 0.4);
            transition: all 0.2s;
        }

        button:hover { background: #ff6b81; transform: translateY(-2px); }
        button:active { transform: translateY(0); }

        /* Loading */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-container">
        <div class="card">
            <h1>PC Builder Sim</h1>
            <p class="instruction">Left Click to Rotate | Scroll to Zoom | <b>Click a part to identify it.</b></p>
        </div>
        
        <div class="card" id="info-panel" style="display: none;">
            <h2 id="part-title">Component Name</h2>
            <p id="part-desc">Description goes here.</p>
        </div>
    </div>

    <div id="controls">
        <button id="explode-btn">Explode View</button>
        <button id="reset-btn">Reset View</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration & Data ---
        const componentData = {
            "CPU": {
                title: "CPU (Central Processing Unit)",
                desc: "The 'Brain' of the computer. It performs calculations and executes instructions. It gets very hot, which is why it's covered by a fan!",
                color: 0xcccccc
            },
            "GPU": {
                title: "GPU (Graphics Processing Unit)",
                desc: "The 'Artist'. It handles rendering images, video, and 3D games. It sits in a PCIe slot on the motherboard.",
                color: 0xff4757
            },
            "RAM": {
                title: "RAM (Random Access Memory)",
                desc: "The 'Short-term Memory'. It stores data the CPU is using right now. It's very fast but loses data when power is off.",
                color: 0x2ed573
            },
            "Motherboard": {
                title: "Motherboard",
                desc: "The 'Nervous System'. A large circuit board that connects all the other components together so they can talk to each other.",
                color: 0x3742fa
            },
            "PSU": {
                title: "PSU (Power Supply Unit)",
                desc: "The 'Heart'. It converts electricity from the wall outlet into power that the computer parts can use.",
                color: 0x2f3542
            },
            "Storage": {
                title: "Storage (SSD/HDD)",
                desc: "The 'Long-term Memory'. Stores your files, photos, and operating system permanently, even when the computer is off.",
                color: 0xffa502
            },
            "Case": {
                title: "The Tower Case",
                desc: "The 'Skeleton' and 'Skin'. It protects the internal components and helps with airflow to keep things cool.",
                color: 0x57606f
            }
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        // Add some fog for depth
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);
        
        const pointLight = new THREE.PointLight(0x4db5ff, 5, 10);
        pointLight.position.set(0, 2, 0);
        scene.add(pointLight);

        // --- Part Generation Helper ---
        const parts = []; // Store parts for raycasting
        const interactables = []; // Specific list for raycaster

        function createPart(name, geometry, color, position, parent, explodedOffset) {
            const material = new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.3,
                metalness: 0.4
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(position.x, position.y, position.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { 
                name: name,
                originalPos: position,
                explodedPos: {
                    x: position.x + explodedOffset.x,
                    y: position.y + explodedOffset.y,
                    z: position.z + explodedOffset.z
                }
            };

            parent.add(mesh);
            interactables.push(mesh);
            parts.push(mesh);
            return mesh;
        }

        // --- Build the Computer ---
        
        // 1. Root Container (The PC)
        const pcGroup = new THREE.Group();
        scene.add(pcGroup);

        // 2. Motherboard (The Base)
        const moboGeo = new THREE.BoxGeometry(3, 0.1, 3);
        const motherboard = createPart("Motherboard", moboGeo, 0x222f3e, {x:0, y:-1, z:0}, pcGroup, {x:0, y:0, z:0});

        // 3. CPU (On Mobo)
        const cpuGeo = new THREE.BoxGeometry(0.8, 0.1, 0.8);
        const cpu = createPart("CPU", cpuGeo, 0xc0c0c0, {x:0, y:0.1, z:0}, motherboard, {x:0, y:1.5, z:0});
        
        // CPU Fan (Visual only, child of CPU)
        const fanGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.2, 32);
        const fan = new THREE.Mesh(fanGeo, new THREE.MeshStandardMaterial({color: 0x333333}));
        fan.position.y = 0.2;
        fan.rotation.x = Math.PI / 2; // Lay flat
        fan.userData = { name: "CPU" }; // Pass click to CPU
        cpu.add(fan);

        // 4. RAM (On Mobo)
        const ramGeo = new THREE.BoxGeometry(0.1, 0.8, 2);
        const ram1 = createPart("RAM", ramGeo, 0x2ed573, {x:1, y:0.4, z:0}, motherboard, {x:2, y:1, z:0});
        
        // 5. GPU (On Mobo - Perpendicular)
        const gpuGeo = new THREE.BoxGeometry(2.5, 0.5, 0.2); // Looks like a card
        const gpu = createPart("GPU", gpuGeo, 0xff4757, {x:-0.5, y:0.5, z:1}, motherboard, {x:-2, y:2, z:3});

        // 6. Case (Transparent Shell)
        const caseGeo = new THREE.BoxGeometry(3.5, 4.5, 5);
        const caseMat = new THREE.MeshPhysicalMaterial({
            color: 0x8899a6,
            transparent: true,
            opacity: 0.1,
            transmission: 0.2,
            roughness: 0,
            side: THREE.DoubleSide
        });
        const pcCase = new THREE.Mesh(caseGeo, caseMat);
        pcCase.position.set(0, 0.5, 0); // Center around contents
        pcGroup.add(pcCase);
        // We generally don't want the case to block clicks, but let's make it clickable if they hit the edge
        pcCase.userData = { name: "Case", originalPos: pcCase.position, explodedPos: pcCase.position };
        // Don't add case to interactables array to allow clicking inside easily, 
        // OR make it invisible to raycaster. Let's rely on PSU/HDD for "Case" area clicks.

        // 7. PSU (Power Supply) - Separate from Mobo, attached to case
        const psuGeo = new THREE.BoxGeometry(1.5, 1, 1.5);
        const psu = createPart("PSU", psuGeo, 0x2f3542, {x:-0.8, y:-1.5, z:-1.5}, pcGroup, {x:-3, y:-1.5, z:-4});

        // 8. Storage (HDD/SSD) - Front of case
        const storageGeo = new THREE.BoxGeometry(1, 0.3, 1.5);
        const storage = createPart("Storage", storageGeo, 0xffa502, {x:0.8, y:-1.5, z:1.5}, pcGroup, {x:3, y:-1.5, z:4});

        // --- Interaction Logic ---
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedPart = null;

        // Highlight Material
        const highlightColor = new THREE.Color(0xffff00);

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables, false); // False = no recursive, hit boxes only

            if (intersects.length > 0) {
                const object = intersects[0].object;
                const data = componentData[object.userData.name];
                
                if (data) {
                    showInfo(data);
                    highlightPart(object);
                }
            } else {
                // Check if we hit the CPU fan (which is a child)
                 const recursiveIntersects = raycaster.intersectObjects(interactables, true);
                 if(recursiveIntersects.length > 0) {
                     // logic to bubble up to parent if needed, handled by userData.name sharing
                     const object = recursiveIntersects[0].object;
                     const name = object.userData.name || object.parent.userData.name;
                     if(componentData[name]) {
                         showInfo(componentData[name]);
                         highlightPart(object.parent.type === 'Mesh' ? object.parent : object);
                     }
                 }
            }
        }

        function highlightPart(mesh) {
            // Reset previous emissive
            interactables.forEach(p => {
                if(p.material.emissive) p.material.emissive.setHex(0x000000);
            });
            // Set new emissive
            if(mesh.material && mesh.material.emissive) {
                mesh.material.emissive.setHex(0x555555);
            }
        }

        function showInfo(data) {
            const panel = document.getElementById('info-panel');
            const title = document.getElementById('part-title');
            const desc = document.getElementById('part-desc');
            
            panel.style.display = 'block';
            panel.style.transform = 'scale(0.9)';
            setTimeout(() => panel.style.transform = 'scale(1)', 50); // slight pop effect
            
            title.innerText = data.title;
            title.style.color = '#' + data.color.toString(16).padStart(6, '0');
            desc.innerText = data.desc;
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation / Explode Logic ---
        let isExploded = false;

        document.getElementById('explode-btn').addEventListener('click', () => { isExploded = true; });
        document.getElementById('reset-btn').addEventListener('click', () => { isExploded = false; });

        function animate() {
            requestAnimationFrame(animate);

            // Lerp positions for smooth explosion
            parts.forEach(part => {
                const target = isExploded ? part.userData.explodedPos : part.userData.originalPos;
                
                // Simple Linear Interpolation (Lerp) towards target
                part.position.x += (target.x - part.position.x) * 0.1;
                part.position.y += (target.y - part.position.y) * 0.1;
                part.position.z += (target.z - part.position.z) * 0.1;
            });

            // Idle Rotation
            if(!isExploded) {
                pcGroup.rotation.y += 0.002;
            } else {
                // Slow down rotation when exploded so they can study parts
                pcGroup.rotation.y += 0.0005;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>
