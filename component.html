<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Mini PC Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #1c1c1e; color: #f5f5f7; }
        
        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(28, 28, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 18px;
            padding: 24px;
            margin-bottom: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        h1 { margin: 0 0 8px 0; font-size: 1.4rem; font-weight: 600; background: linear-gradient(90deg, #fff, #a1a1aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        h2 { margin: 0 0 6px 0; font-size: 1.1rem; color: #2997ff; }
        p { line-height: 1.5; font-size: 0.9rem; color: #a1a1aa; margin: 0; }
        
        .instruction { font-size: 0.8rem; color: #6e6e73; margin-top: 10px; display: block; }
        .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.7rem; background: #2997ff; color: white; margin-bottom: 5px;}

        /* Buttons */
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }

        button {
            background: #333;
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        button:hover { background: #444; transform: scale(1.05); }
        button.primary { background: #0071e3; border: none; }
        button.primary:hover { background: #0077ed; }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-container">
        <div class="card">
            <h1>Modern Mini PC Simulator</h1>
            <p>An educational look inside an ultra-compact computer architecture, based on Apple's Mac Mini M4.</p>
            <span class="instruction">Left Click to Rotate<br>Scroll to Zoom<br><b>Click parts to identify</b></span>
        </div>
        
        <div class="card" id="info-panel" style="display: none; opacity: 0; transform: translateY(10px);">
            <h2 id="part-title">Component Name</h2>
            <p id="part-desc">Description goes here.</p>
        </div>
    </div>

    <div id="controls">
        <button id="explode-btn" class="primary">Explode View</button>
        <button id="reset-btn">Reset</button>
        <button id="flip-btn">Flip Upside Down</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // --- Data: Apple Silicon Terms ---
        const componentData = {
            "Case": {
                title: "Aluminum Unibody",
                desc: "The size is very compact at 13cm x 13cm. It acts as the 'skeleton' of this mini desktop computer. The entire case is made of aluminum and actually helps with structure as well as dissipate heat!",
                color: 0x888888
            },
            "Foot": {
                title: "Rubberized Foot",
                desc: "Not only the foot is rubberized to prevent slippage, the foot was also chamfered such that air can get inside the computer!",
                color: 0xffffff
            },
            "SoC": {
                title: "Apple M4 Chip (SoC)",
                desc: "In traditional PCs, the CPU and GPU (graphics processing unit) are separate. Here, the CPU, GPU, and other processing units are all fused into one silicon chip for minimal latency and maximum efficiency.",
                color: 0x00f2de
            },
            "UnifiedMemory": {
                title: "Unified Memory (RAM)",
                desc: "Instead of separate RAM sticks, memory is soldered right next to the SoC chip. This approach allows the CPU and GPU (graphics processing unit) to share data instantly without copying it.",
                color: 0x2997ff
            },
            "Fan": {
                title: "Blower Fan",
                desc: "The 'Lungs'. It pulls cool air in from the bottom foot, pushes it through the heatsink, and vents it out the back. It's vital for such a small box.",
                color: 0xdddddd
            },
            "Heatsink": {
                title: "Radial Heatsink",
                desc: "A spiral of metal fins with heatpipes that sits on top of the SoC chip. It absorbs heat from the chip so the fan can blow it away.",
                color: 0xb87333
            },
            "LogicBoard": {
                title: "Logic Board",
                desc: "The main circuit board. It's much smaller than a standard PC motherboard. It holds the SoC, storage, and data input/output ports.",
                color: 0x115d33
            },
            "PSU": {
                title: "Internal Power Supply",
                desc: "Surprisingly, the power brick is INSIDE this tiny box! It converts wall power (AC) to safe DC power for the board.",
                color: 0xfffc00
            },
            "Storage": {
                title: "NAND Storage",
                desc: "Long-term storage chips. These are often on a removable daughterboard, while some models have them soldered on the logic board.",
                color: 0x555555
            },
            "PowerButton": {
                title: "The Power Button",
                desc: "The infamous button located on the BOTTOM. You have to tilt the computer to turn it on!",
                color: 0xffffff
            }
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1c1c1e);
        scene.fog = new THREE.Fog(0x1c1c1e, 8, 25);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(6, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 3;
        controls.maxDistance = 15;

        // --- Lighting (Studio Setup) ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(5, 10, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        
        const fillLight = new THREE.DirectionalLight(0xaaccff, 0.5);
        fillLight.position.set(-5, 2, -5);
        scene.add(fillLight);

        // --- Builder Helper ---
        const interactables = [];
        const parts = [];

        function createPart(name, geometry, materialOpts, pos, parent, explodeOffset) {
            const mat = new THREE.MeshStandardMaterial({
                roughness: 0.4,
                metalness: 0.5,
                ...materialOpts
            });
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { 
                name: name,
                originalPos: { ...pos },
                explodePos: { x: pos.x + explodeOffset.x, y: pos.y + explodeOffset.y, z: pos.z + explodeOffset.z }
            };
            
            parent.add(mesh);
            interactables.push(mesh);
            parts.push(mesh);
            return mesh;
        }

        function createMacMiniStyleBox(width = 2, depth = 2, height = 0.4, radius = 0.12, curveSegments = 8) {
            const shape = new THREE.Shape();
            const hw = width / 2;
            const hd = depth / 2;

            // Rounded rectangle, centered at (0,0)
            shape.moveTo(-hw + radius, -hd);
            shape.lineTo( hw - radius, -hd);
            shape.quadraticCurveTo( hw, -hd,  hw, -hd + radius);     // "bottom right"

            shape.lineTo( hw,  hd - radius);
            shape.quadraticCurveTo( hw,  hd,  hw - radius, hd);       // "top right"

            shape.lineTo(-hw + radius,  hd);
            shape.quadraticCurveTo(-hw,  hd, -hw, hd - radius);       // "top left"

            shape.lineTo(-hw, -hd + radius);
            shape.quadraticCurveTo(-hw, -hd, -hw + radius, -hd);      // "bottom left"

            const extrudeSettings = {
                depth: height,          // how tall the object will be after rotation
                bevelEnabled: false,
                steps: 1,
                curveSegments: curveSegments
            };

            let geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            // Rotate 90Â° around X-axis so extrusion direction becomes +Y
            geometry.rotateX(Math.PI / 2);

            // Optional: center origin after rotation
            geometry.center();

            geometry.computeVertexNormals();

            return geometry;
        }

        // --- Build the Mac Mini M4 ---
        const macGroup = new THREE.Group();
        scene.add(macGroup);

        // 1. Bottom Foot (Air Intake)
        const footGeo = new THREE.CylinderGeometry(2, 1.6, 0.4, 64);
        const foot = createPart("Foot", footGeo, { color: 0x111111, roughness: 0.9 }, {x:0, y:-0.2, z:0}, macGroup, {x:0, y:-1.5, z:0});

        // 1.5 The Power Button (On the bottom!)
        const btnGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.08, 64);
        const pwrBtn = createPart("PowerButton", btnGeo, { color: 0xffffff, emissive: 0x333333 }, {x:1.5, y:-0.18, z:1.5}, macGroup, {x:0, y:-1.6, z:0});
        // Attach to case visually, but logic-wise separate
        pwrBtn.rotation.x = Math.PI; 

        // 2. Logic Board (The base)
        const boardGeo = new RoundedBoxGeometry(3.5, 0.05, 3.5, 4,);
        const logicBoard = createPart("LogicBoard", boardGeo, { color: 0x2f3640 }, {x:0, y:-0.1, z:0}, macGroup, {x:0, y:0.8, z:0});

        // 3. The M4 SoC (Central Chip)
        const m4Geo = new THREE.BoxGeometry(0.8, 0.02, 0.8);
        const m4Chip = createPart("SoC", m4Geo, { color: 0xe0e0e0, metalness: 0.8, roughness: 0.2 }, {x:0, y:0.04, z:0}, logicBoard, {x:0, y:0.1, z:0});
        
        // 3.1 Unified Memory (Two small rectangles ON the SoC package)
        const ramGeo = new THREE.BoxGeometry(0.2, 0.03, 0.5);
        const ram1 = createPart("UnifiedMemory", ramGeo, { color: 0x333333 }, {x:-0.5, y:0.04, z:0}, logicBoard, {x:0, y:0.15, z:0});
        const ram2 = createPart("UnifiedMemory", ramGeo, { color: 0x333333 }, {x:0.5, y:0.04, z:0}, logicBoard, {x:0, y:0.2, z:0});

        // 3.2 Storage (NAND Module - Removable on M4)
        const ssdGeo = new THREE.BoxGeometry(0.6, 0.05, 1.2);
        const ssd = createPart("Storage", ssdGeo, { color: 0x111111 }, {x:1.2, y:0.04, z:-0.8}, logicBoard, {x:0.5, y:0.2, z:0});

        // 4. Heatsink (Radial/Spiral fins)
        const sinkGeo = new THREE.CylinderGeometry(1.6, 1.6, 0.3, 32);
        const heatsink = createPart("Heatsink", sinkGeo, { color: 0xb87333 }, {x:0, y:-0.02, z:0}, m4Chip, {x:0, y:1.4, z:0});

        // 5. Blower Fan
        const fanGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
        const fan = createPart("Fan", fanGeo, { color: 0x111111 }, {x:0, y:0.3, z:0}, heatsink, {x:0, y:0.4, z:0});
        
        // 6. Power Supply (Internal Board)
        const psuGeo = new THREE.BoxGeometry(3.5, 0.3, 1.0);
        const psu = createPart("PSU", psuGeo, { color: 0x222222 }, {x:0, y:0.4, z:-1.2}, logicBoard, {x:0, y:0.4, z:-0.5});

        // 7. The Case (Shell)
        const caseGeo = new createMacMiniStyleBox(4, 4, 1.4, 0.8, 64);
        // We make the case slightly transparent or open bottom so we can see inside during explode
        const caseMesh = createPart("Case", caseGeo, { color: 0xc0c0c0, metalness: 0.6, roughness: 0.3 }, {x:0, y:0.5, z:0}, macGroup, {x:0, y:3.5, z:0});
        
        // Add Apple Logo to top
        const logoGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.01, 32);
        const logo = new THREE.Mesh(logoGeo, new THREE.MeshBasicMaterial({ color: 0x111111 }));
        logo.position.y = 0.71;
        caseMesh.add(logo);

        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('click', () => {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables);
            if (intersects.length > 0) {
                const name = intersects[0].object.userData.name;
                const data = componentData[name];
                
                // Highlight
                interactables.forEach(m => {
                    if(m.material.emissive) m.material.emissive.setHex(0x000000);
                });
                if(intersects[0].object.material.emissive) {
                    intersects[0].object.material.emissive.setHex(0x333333);
                }

                // Show UI
                const panel = document.getElementById('info-panel');
                panel.style.display = 'block';
                setTimeout(() => { panel.style.opacity = '1'; panel.style.transform = 'translateY(0)'; }, 10);
                
                document.getElementById('part-title').innerText = data.title;
                document.getElementById('part-desc').innerText = data.desc;
                document.getElementById('part-title').style.color = '#' + data.color.toString(16).padStart(6, '0');
            }
        });

        // --- Controls ---
        let isExploded = false;
        let isFlipped = false;

        document.getElementById('explode-btn').addEventListener('click', () => { isExploded = true; });
        document.getElementById('reset-btn').addEventListener('click', () => { 
            isExploded = false; 
            isFlipped = false; 
        });
        document.getElementById('flip-btn').addEventListener('click', () => { isFlipped = !isFlipped; });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Smooth Explode
            parts.forEach(part => {
                const target = isExploded ? part.userData.explodePos : part.userData.originalPos;
                part.position.lerp(new THREE.Vector3(target.x, target.y, target.z), 0.1);
            });

            // Smooth Flip
            const targetRot = isFlipped ? Math.PI : 0;
            // Use a simple lerp for rotation grouping
            // Note: Quaternions are better but simple axis lerp works for this limited scope
            const currentRot = macGroup.rotation.x;
            if(Math.abs(currentRot - targetRot) > 0.001) {
                macGroup.rotation.x += (targetRot - currentRot) * 0.05;
            }

            // Fan spin
            if(isExploded) fan.rotation.y += 0.05;

            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>

